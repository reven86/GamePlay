#ifndef GP_NO_PLATFORM
#ifdef EMSCRIPTEN

#include "Base.h"
#include "Platform.h"
#include "FileSystem.h"
#include "Game.h"
#include "Form.h"
#include "ScriptController.h"

#include <X11/X.h>
#include <X11/Xlib.h>
#include <sys/time.h>
#include <EGL/egl.h>
#include <EGL/eglext.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <fstream>

#include <emscripten/emscripten.h>
#include <emscripten/html5.h>

#define TOUCH_COUNT_MAX     4
#define MAX_GAMEPADS 4

using namespace std;

int __argc = 0;
char** __argv = 0;

enum GamepadAxisInfoFlags
{
    GP_AXIS_SKIP = 0x1,
    GP_AXIS_IS_DPAD = 0x2,
    GP_AXIS_IS_NEG = 0x4,
    GP_AXIS_IS_XAXIS = 0x8,
    GP_AXIS_IS_TRIGGER = 0x10
};

enum GamepadAxisInfoNormalizeFunction
{
    NEG_TO_POS,
    ZERO_TO_POS
};

struct GamepadJoystickAxisInfo
{
    int axisIndex;
    unsigned int joystickIndex;
    unsigned long flags;
    int mappedPosArg;
    int mappedNegArg;
    float deadZone;
    GamepadAxisInfoNormalizeFunction mapFunc;
};

struct GamepadInfoEntry
{
    unsigned int vendorId;
    unsigned int productId;
    const char* productName;
    unsigned int numberOfJS;
    unsigned int numberOfAxes;
    unsigned int numberOfButtons;
    unsigned int numberOfTriggers;

    GamepadJoystickAxisInfo* axes;
    long* buttons;
};

struct ConnectedGamepadDevInfo
{
    dev_t deviceId;
    gameplay::GamepadHandle fd;
    const GamepadInfoEntry& gamepadInfo;
};

struct timespec __timespec;
static double __timeStart;
static double __timeAbsolute;
static bool __vsync = WINDOW_VSYNC;
static bool __mouseCaptured = false;
static int __mouseCapturePointX = 0;
static int __mouseCapturePointY = 0;
static bool __multiSampling = false;
static bool __cursorVisible = true;
static bool __leftMouseButtonPressed = false;
static EGLDisplay __eglDisplay = EGL_NO_DISPLAY;
static EGLContext __eglContext = EGL_NO_CONTEXT;
static EGLSurface __eglSurface = EGL_NO_SURFACE;
static EGLConfig __eglConfig = 0;
static const char* __glExtensions;
PFNGLBINDVERTEXARRAYOESPROC glBindVertexArray = NULL;
PFNGLDELETEVERTEXARRAYSOESPROC glDeleteVertexArrays = NULL;
PFNGLGENVERTEXARRAYSOESPROC glGenVertexArrays = NULL;
PFNGLISVERTEXARRAYOESPROC glIsVertexArray = NULL;
static int __windowSize[2];
static list<ConnectedGamepadDevInfo> __connectedGamepads;

static EGLenum checkErrorEGL(const char* msg)
{
    GP_ASSERT(msg);
    static const char* errmsg[] =
    {
        "EGL function succeeded",
        "EGL is not initialized, or could not be initialized, for the specified display",
        "EGL cannot access a requested resource",
        "EGL failed to allocate resources for the requested operation",
        "EGL fail to access an unrecognized attribute or attribute value was passed in an attribute list",
        "EGLConfig argument does not name a valid EGLConfig",
        "EGLContext argument does not name a valid EGLContext",
        "EGL current surface of the calling thread is no longer valid",
        "EGLDisplay argument does not name a valid EGLDisplay",
        "EGL arguments are inconsistent",
        "EGLNativePixmapType argument does not refer to a valid native pixmap",
        "EGLNativeWindowType argument does not refer to a valid native window",
        "EGL one or more argument values are invalid",
        "EGLSurface argument does not name a valid surface configured for rendering",
        "EGL power management event has occurred",
    };
    EGLenum error = eglGetError();
    printf("%s: %s.", msg, errmsg[error - EGL_SUCCESS]);
    return error;
}

static gameplay::Keyboard::Key getKey(int win32KeyCode, bool shiftDown)
{
    switch (win32KeyCode)
    {
    case 0x13/*VK_PAUSE*/:
        return gameplay::Keyboard::KEY_PAUSE;
    case 0x91/*VK_SCROLL*/:
        return gameplay::Keyboard::KEY_SCROLL_LOCK;
    case 0x2A/*VK_PRINT*/:
    case 0x2C/*VK_SNAPSHOT*/:   // print-screen key
        return gameplay::Keyboard::KEY_PRINT;
    case 0x1B/*VK_ESCAPE*/:
        return gameplay::Keyboard::KEY_ESCAPE;
    case 0x08/*VK_BACK*/:
    case 0x7F/*VK_F16*/: // generated by CTRL + BACKSPACE
        return gameplay::Keyboard::KEY_BACKSPACE;
    case 0x09/*VK_TAB*/:
        return shiftDown ? gameplay::Keyboard::KEY_BACK_TAB : gameplay::Keyboard::KEY_TAB;
    case 0x0D/*VK_RETURN*/:
        return gameplay::Keyboard::KEY_RETURN;
    case 0x14/*VK_CAPITAL*/:
        return gameplay::Keyboard::KEY_CAPS_LOCK;
    case 0x10/*VK_SHIFT*/:
        return gameplay::Keyboard::KEY_SHIFT;
    case 0x11/*VK_CONTROL*/:
        return gameplay::Keyboard::KEY_CTRL;
    case 0x12/*VK_MENU*/:
        return gameplay::Keyboard::KEY_ALT;
    case 0x5D/*VK_APPS*/:
        return gameplay::Keyboard::KEY_MENU;
    case 0xA0/*VK_LSHIFT*/:
        return gameplay::Keyboard::KEY_SHIFT;
    case 0xA1/*VK_RSHIFT*/:
        return gameplay::Keyboard::KEY_SHIFT;
    case 0xA2/*VK_LCONTROL*/:
        return gameplay::Keyboard::KEY_CTRL;
    case 0xA3/*VK_RCONTROL*/:
        return gameplay::Keyboard::KEY_CTRL;
    case 0xA4/*VK_LMENU*/:
        return gameplay::Keyboard::KEY_ALT;
    case 0xA5/*VK_RMENU*/:
        return gameplay::Keyboard::KEY_ALT;
    case 0x5B/*VK_LWIN*/:
    case 0x5C/*VK_RWIN*/:
        return gameplay::Keyboard::KEY_HYPER;
    case 0xAA/*VK_BROWSER_SEARCH*/:
        return gameplay::Keyboard::KEY_SEARCH;
    case 0x2D/*VK_INSERT*/:
        return gameplay::Keyboard::KEY_INSERT;
    case 0x24/*VK_HOME*/:
        return gameplay::Keyboard::KEY_HOME;
    case 0x21/*VK_PRIOR*/:
        return gameplay::Keyboard::KEY_PG_UP;
    case 0x2E/*VK_DELETE*/:
        return gameplay::Keyboard::KEY_DELETE;
    case 0x23/*VK_END*/:
        return gameplay::Keyboard::KEY_END;
    case 0x22/*VK_NEXT*/:
        return gameplay::Keyboard::KEY_PG_DOWN;
    case 0x25/*VK_LEFT*/:
        return gameplay::Keyboard::KEY_LEFT_ARROW;
    case 0x27/*VK_RIGHT*/:
        return gameplay::Keyboard::KEY_RIGHT_ARROW;
    case 0x26/*VK_UP*/:
        return gameplay::Keyboard::KEY_UP_ARROW;
    case 0x28/*VK_DOWN*/:
        return gameplay::Keyboard::KEY_DOWN_ARROW;
    case 0x90/*VK_NUMLOCK*/:
        return gameplay::Keyboard::KEY_NUM_LOCK;
    case 0x6B/*VK_ADD*/:
        return gameplay::Keyboard::KEY_KP_PLUS;
    case 0x6D/*VK_SUBTRACT*/:
        return gameplay::Keyboard::KEY_KP_MINUS;
    case 0x6A/*VK_MULTIPLY*/:
        return gameplay::Keyboard::KEY_KP_MULTIPLY;
    case 0x6F/*VK_DIVIDE*/:
        return gameplay::Keyboard::KEY_KP_DIVIDE;
    case 0x67/*VK_NUMPAD7*/:
        return gameplay::Keyboard::KEY_KP_HOME;
    case 0x68/*VK_NUMPAD8*/:
        return gameplay::Keyboard::KEY_KP_UP;
    case 0x69/*VK_NUMPAD9*/:
        return gameplay::Keyboard::KEY_KP_PG_UP;
    case 0x64/*VK_NUMPAD4*/:
        return gameplay::Keyboard::KEY_KP_LEFT;
    case 0x65/*VK_NUMPAD5*/:
        return gameplay::Keyboard::KEY_KP_FIVE;
    case 0x66/*VK_NUMPAD6*/:
        return gameplay::Keyboard::KEY_KP_RIGHT;
    case 0x61/*VK_NUMPAD1*/:
        return gameplay::Keyboard::KEY_KP_END;
    case 0x62/*VK_NUMPAD2*/:
        return gameplay::Keyboard::KEY_KP_DOWN;
    case 0x63/*VK_NUMPAD3*/:
        return gameplay::Keyboard::KEY_KP_PG_DOWN;
    case 0x60/*VK_NUMPAD0*/:
        return gameplay::Keyboard::KEY_KP_INSERT;
    case 0x6E/*VK_DECIMAL*/:
        return gameplay::Keyboard::KEY_KP_DELETE;
    case 0x70/*VK_F1*/:
        return gameplay::Keyboard::KEY_F1;
    case 0x71/*VK_F2*/:
        return gameplay::Keyboard::KEY_F2;
    case 0x72/*VK_F3*/:
        return gameplay::Keyboard::KEY_F3;
    case 0x73/*VK_F4*/:
        return gameplay::Keyboard::KEY_F4;
    case 0x74/*VK_F5*/:
        return gameplay::Keyboard::KEY_F5;
    case 0x75/*VK_F6*/:
        return gameplay::Keyboard::KEY_F6;
    case 0x76/*VK_F7*/:
        return gameplay::Keyboard::KEY_F7;
    case 0x77/*VK_F8*/:
        return gameplay::Keyboard::KEY_F8;
    case 0x78/*VK_F9*/:
        return gameplay::Keyboard::KEY_F9;
    case 0x79/*VK_F10*/:
        return gameplay::Keyboard::KEY_F10;
    case 0x7A/*VK_F11*/:
        return gameplay::Keyboard::KEY_F11;
    case 0x7B/*VK_F12*/:
        return gameplay::Keyboard::KEY_F12;
    case 0x20/*VK_SPACE*/:
        return gameplay::Keyboard::KEY_SPACE;
    case 0x30:
        return shiftDown ? gameplay::Keyboard::KEY_RIGHT_PARENTHESIS : gameplay::Keyboard::KEY_ZERO;
    case 0x31:
        return shiftDown ? gameplay::Keyboard::KEY_EXCLAM : gameplay::Keyboard::KEY_ONE;
    case 0x32:
        return shiftDown ? gameplay::Keyboard::KEY_AT : gameplay::Keyboard::KEY_TWO;
    case 0x33:
        return shiftDown ? gameplay::Keyboard::KEY_NUMBER : gameplay::Keyboard::KEY_THREE;
    case 0x34:
        return shiftDown ? gameplay::Keyboard::KEY_DOLLAR : gameplay::Keyboard::KEY_FOUR;
    case 0x35:
        return shiftDown ? gameplay::Keyboard::KEY_PERCENT : gameplay::Keyboard::KEY_FIVE;
    case 0x36:
        return shiftDown ? gameplay::Keyboard::KEY_CIRCUMFLEX : gameplay::Keyboard::KEY_SIX;
    case 0x37:
        return shiftDown ? gameplay::Keyboard::KEY_AMPERSAND : gameplay::Keyboard::KEY_SEVEN;
    case 0x38:
        return shiftDown ? gameplay::Keyboard::KEY_ASTERISK : gameplay::Keyboard::KEY_EIGHT;
    case 0x39:
        return shiftDown ? gameplay::Keyboard::KEY_LEFT_PARENTHESIS : gameplay::Keyboard::KEY_NINE;
    case 0xBB/*VK_OEM_PLUS*/:
        return shiftDown ? gameplay::Keyboard::KEY_EQUAL : gameplay::Keyboard::KEY_PLUS;
    case 0xBC/*VK_OEM_COMMA*/:
        return shiftDown ? gameplay::Keyboard::KEY_LESS_THAN : gameplay::Keyboard::KEY_COMMA;
    case 0xBD/*VK_OEM_MINUS*/:
        return shiftDown ? gameplay::Keyboard::KEY_UNDERSCORE : gameplay::Keyboard::KEY_MINUS;
    case 0xBE/*VK_OEM_PERIOD*/:
        return shiftDown ? gameplay::Keyboard::KEY_GREATER_THAN : gameplay::Keyboard::KEY_PERIOD;
    case 0xBA/*VK_OEM_1*/:
        return shiftDown ? gameplay::Keyboard::KEY_COLON : gameplay::Keyboard::KEY_SEMICOLON;
    case 0xBF/*VK_OEM_2*/:
        return shiftDown ? gameplay::Keyboard::KEY_QUESTION : gameplay::Keyboard::KEY_SLASH;
    case 0xC0/*VK_OEM_3*/:
        return shiftDown ? gameplay::Keyboard::KEY_TILDE : gameplay::Keyboard::KEY_GRAVE;
    case 0xDB/*VK_OEM_4*/:
        return shiftDown ? gameplay::Keyboard::KEY_LEFT_BRACE : gameplay::Keyboard::KEY_LEFT_BRACKET;
    case 0xDC/*VK_OEM_5*/:
        return shiftDown ? gameplay::Keyboard::KEY_BAR : gameplay::Keyboard::KEY_BACK_SLASH;
    case 0xDD/*VK_OEM_6*/:
        return shiftDown ? gameplay::Keyboard::KEY_RIGHT_BRACE : gameplay::Keyboard::KEY_RIGHT_BRACKET;
    case 0xDE/*VK_OEM_7*/:
        return shiftDown ? gameplay::Keyboard::KEY_QUOTE : gameplay::Keyboard::KEY_APOSTROPHE;
    case 0x41:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_A : gameplay::Keyboard::KEY_A;
    case 0x42:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_B : gameplay::Keyboard::KEY_B;
    case 0x43:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_C : gameplay::Keyboard::KEY_C;
    case 0x44:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_D : gameplay::Keyboard::KEY_D;
    case 0x45:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_E : gameplay::Keyboard::KEY_E;
    case 0x46:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_F : gameplay::Keyboard::KEY_F;
    case 0x47:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_G : gameplay::Keyboard::KEY_G;
    case 0x48:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_H : gameplay::Keyboard::KEY_H;
    case 0x49:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_I : gameplay::Keyboard::KEY_I;
    case 0x4A:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_J : gameplay::Keyboard::KEY_J;
    case 0x4B:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_K : gameplay::Keyboard::KEY_K;
    case 0x4C:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_L : gameplay::Keyboard::KEY_L;
    case 0x4D:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_M : gameplay::Keyboard::KEY_M;
    case 0x4E:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_N : gameplay::Keyboard::KEY_N;
    case 0x4F:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_O : gameplay::Keyboard::KEY_O;
    case 0x50:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_P : gameplay::Keyboard::KEY_P;
    case 0x51:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_Q : gameplay::Keyboard::KEY_Q;
    case 0x52:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_R : gameplay::Keyboard::KEY_R;
    case 0x53:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_S : gameplay::Keyboard::KEY_S;
    case 0x54:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_T : gameplay::Keyboard::KEY_T;
    case 0x55:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_U : gameplay::Keyboard::KEY_U;
    case 0x56:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_V : gameplay::Keyboard::KEY_V;
    case 0x57:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_W : gameplay::Keyboard::KEY_W;
    case 0x58:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_X : gameplay::Keyboard::KEY_X;
    case 0x59:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_Y : gameplay::Keyboard::KEY_Y;
    case 0x5A:
        return shiftDown ? gameplay::Keyboard::KEY_CAPITAL_Z : gameplay::Keyboard::KEY_Z;
    default:
        return gameplay::Keyboard::KEY_NONE;
    }
}

/**
 * Returns the unicode value for the given keycode or zero if the key is not a valid printable character.
 */
static int getUnicode(gameplay::Keyboard::Key key)
{
    switch (key)
    {
        case gameplay::Keyboard::KEY_BACKSPACE:
            return 0x0008;
        case gameplay::Keyboard::KEY_TAB:
            return 0x0009;
        case gameplay::Keyboard::KEY_RETURN:
        case gameplay::Keyboard::KEY_KP_ENTER:
            return 0x000A;
        case gameplay::Keyboard::KEY_ESCAPE:
            return 0x001B;
        case gameplay::Keyboard::KEY_SPACE:
        case gameplay::Keyboard::KEY_EXCLAM:
        case gameplay::Keyboard::KEY_QUOTE:
        case gameplay::Keyboard::KEY_NUMBER:
        case gameplay::Keyboard::KEY_DOLLAR:
        case gameplay::Keyboard::KEY_PERCENT:
        case gameplay::Keyboard::KEY_CIRCUMFLEX:
        case gameplay::Keyboard::KEY_AMPERSAND:
        case gameplay::Keyboard::KEY_APOSTROPHE:
        case gameplay::Keyboard::KEY_LEFT_PARENTHESIS:
        case gameplay::Keyboard::KEY_RIGHT_PARENTHESIS:
        case gameplay::Keyboard::KEY_ASTERISK:
        case gameplay::Keyboard::KEY_PLUS:
        case gameplay::Keyboard::KEY_COMMA:
        case gameplay::Keyboard::KEY_MINUS:
        case gameplay::Keyboard::KEY_PERIOD:
        case gameplay::Keyboard::KEY_SLASH:
        case gameplay::Keyboard::KEY_ZERO:
        case gameplay::Keyboard::KEY_ONE:
        case gameplay::Keyboard::KEY_TWO:
        case gameplay::Keyboard::KEY_THREE:
        case gameplay::Keyboard::KEY_FOUR:
        case gameplay::Keyboard::KEY_FIVE:
        case gameplay::Keyboard::KEY_SIX:
        case gameplay::Keyboard::KEY_SEVEN:
        case gameplay::Keyboard::KEY_EIGHT:
        case gameplay::Keyboard::KEY_NINE:
        case gameplay::Keyboard::KEY_COLON:
        case gameplay::Keyboard::KEY_SEMICOLON:
        case gameplay::Keyboard::KEY_LESS_THAN:
        case gameplay::Keyboard::KEY_EQUAL:
        case gameplay::Keyboard::KEY_GREATER_THAN:
        case gameplay::Keyboard::KEY_QUESTION:
        case gameplay::Keyboard::KEY_AT:
        case gameplay::Keyboard::KEY_CAPITAL_A:
        case gameplay::Keyboard::KEY_CAPITAL_B:
        case gameplay::Keyboard::KEY_CAPITAL_C:
        case gameplay::Keyboard::KEY_CAPITAL_D:
        case gameplay::Keyboard::KEY_CAPITAL_E:
        case gameplay::Keyboard::KEY_CAPITAL_F:
        case gameplay::Keyboard::KEY_CAPITAL_G:
        case gameplay::Keyboard::KEY_CAPITAL_H:
        case gameplay::Keyboard::KEY_CAPITAL_I:
        case gameplay::Keyboard::KEY_CAPITAL_J:
        case gameplay::Keyboard::KEY_CAPITAL_K:
        case gameplay::Keyboard::KEY_CAPITAL_L:
        case gameplay::Keyboard::KEY_CAPITAL_M:
        case gameplay::Keyboard::KEY_CAPITAL_N:
        case gameplay::Keyboard::KEY_CAPITAL_O:
        case gameplay::Keyboard::KEY_CAPITAL_P:
        case gameplay::Keyboard::KEY_CAPITAL_Q:
        case gameplay::Keyboard::KEY_CAPITAL_R:
        case gameplay::Keyboard::KEY_CAPITAL_S:
        case gameplay::Keyboard::KEY_CAPITAL_T:
        case gameplay::Keyboard::KEY_CAPITAL_U:
        case gameplay::Keyboard::KEY_CAPITAL_V:
        case gameplay::Keyboard::KEY_CAPITAL_W:
        case gameplay::Keyboard::KEY_CAPITAL_X:
        case gameplay::Keyboard::KEY_CAPITAL_Y:
        case gameplay::Keyboard::KEY_CAPITAL_Z:
        case gameplay::Keyboard::KEY_LEFT_BRACKET:
        case gameplay::Keyboard::KEY_BACK_SLASH:
        case gameplay::Keyboard::KEY_RIGHT_BRACKET:
        case gameplay::Keyboard::KEY_UNDERSCORE:
        case gameplay::Keyboard::KEY_GRAVE:
        case gameplay::Keyboard::KEY_A:
        case gameplay::Keyboard::KEY_B:
        case gameplay::Keyboard::KEY_C:
        case gameplay::Keyboard::KEY_D:
        case gameplay::Keyboard::KEY_E:
        case gameplay::Keyboard::KEY_F:
        case gameplay::Keyboard::KEY_G:
        case gameplay::Keyboard::KEY_H:
        case gameplay::Keyboard::KEY_I:
        case gameplay::Keyboard::KEY_J:
        case gameplay::Keyboard::KEY_K:
        case gameplay::Keyboard::KEY_L:
        case gameplay::Keyboard::KEY_M:
        case gameplay::Keyboard::KEY_N:
        case gameplay::Keyboard::KEY_O:
        case gameplay::Keyboard::KEY_P:
        case gameplay::Keyboard::KEY_Q:
        case gameplay::Keyboard::KEY_R:
        case gameplay::Keyboard::KEY_S:
        case gameplay::Keyboard::KEY_T:
        case gameplay::Keyboard::KEY_U:
        case gameplay::Keyboard::KEY_V:
        case gameplay::Keyboard::KEY_W:
        case gameplay::Keyboard::KEY_X:
        case gameplay::Keyboard::KEY_Y:
        case gameplay::Keyboard::KEY_Z:
        case gameplay::Keyboard::KEY_LEFT_BRACE:
        case gameplay::Keyboard::KEY_BAR:
        case gameplay::Keyboard::KEY_RIGHT_BRACE:
        case gameplay::Keyboard::KEY_TILDE:
            return key;
        default:
            return 0;
    }
}

namespace gameplay
{

extern void print(const char* format, ...)
{
    GP_ASSERT(format);
    va_list argptr;
    va_start(argptr, format);
    vfprintf(stdout, format, argptr);
    va_end(argptr);
}

extern int strcmpnocase(const char* s1, const char* s2)
{
    return strcasecmp(s1, s2);
}

Platform::Platform(Game* game) : _game(game)
{
}

Platform::~Platform()
{
}

Platform* Platform::create(Game* game)
{

    GP_ASSERT(game);

    FileSystem::setResourcePath("./");
    Platform* platform = new Platform(game);

    // Get the window configuration values
    const char *title = NULL;
    int __width = 0, __height = 0, __samples = 0;
    bool fullscreen = false;
    
    // default window sizes come from canvas
    int tmpFullscreen = 0;
    emscripten_get_canvas_size(&__width, &__height, &tmpFullscreen);
    
    if (game->getConfig())
    {
        Properties* config = game->getConfig()->getNamespace("window", true);
        if (config)
        {
            // Read window title.
            title = config->getString("title");

            // Read window rect.
            int width = config->getInt("width");
            int height = config->getInt("height");
            int samples = config->getInt("samples");
            fullscreen = config->getBool("fullscreen");

            if (width != 0) __width = width;
            if (height != 0) __height = height;
            if (samples != 0) __samples = samples;
        }
    }
    
    __windowSize[0] = __width;
    __windowSize[1] = __height;
    emscripten_set_canvas_size(__width, __height);

    // Construct a fake argv array for GLUT. LLVM seems extra picky about what
    // it will accept here, so we allocate a "real" argv array on the heap, and
    // tear it down after init.
    char *arg1 = (char*)malloc(1);
    char **dummyArgv = (char**)malloc(sizeof(char*));
    dummyArgv[0] = arg1;
    free(dummyArgv[0]);
    free(dummyArgv);

    // Hard-coded to 32-bit/OpenGL ES 2.0.
    // NOTE: EGL_SAMPLE_BUFFERS, EGL_SAMPLES and EGL_DEPTH_SIZE MUST remain at the beginning of the attribute list
    // since they are expected to be at indices 0-5 in config fallback code later.
    // EGL_DEPTH_SIZE is also expected to
    EGLint eglConfigAttrs[] =
    {
        EGL_SAMPLE_BUFFERS, __samples > 0 ? 1 : 0,
        EGL_SAMPLES, __samples,
        EGL_DEPTH_SIZE, 24,
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_ALPHA_SIZE, 8,
        EGL_STENCIL_SIZE, 8,
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
        EGL_NONE
    };
    __multiSampling = __samples > 0;

    EGLint eglConfigCount;
    const EGLint eglContextAttrs[] =
    {
        EGL_CONTEXT_CLIENT_VERSION, 2,
        EGL_NONE
    };

    const EGLint eglSurfaceAttrs[] =
    {
        EGL_RENDER_BUFFER, EGL_BACK_BUFFER,
        EGL_NONE
    };

    if (__eglDisplay == EGL_NO_DISPLAY && __eglContext == EGL_NO_CONTEXT)
    {
        // Get the EGL display and initialize.
        __eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        if (__eglDisplay == EGL_NO_DISPLAY)
        {
            GP_ERROR("eglGetDisplay");
            return NULL;
        }

        if (eglInitialize(__eglDisplay, NULL, NULL) != EGL_TRUE)
        {
            GP_ERROR("eglInitialize");
            return NULL;
        }

        // Try both 24 and 16-bit depth sizes since some hardware (i.e. Tegra) does not support 24-bit depth
        bool validConfig = false;
        EGLint depthSizes[] = { 24, 16 };
        for (unsigned int i = 0; i < 2; ++i)
        {
            eglConfigAttrs[1] = __samples > 0 ? 1 : 0;
            eglConfigAttrs[3] = __samples;
            eglConfigAttrs[5] = depthSizes[i];

            if (eglChooseConfig(__eglDisplay, eglConfigAttrs, &__eglConfig, 1, &eglConfigCount) == EGL_TRUE && eglConfigCount > 0)
            {
                validConfig = true;
                break;
            }

            if (__samples > 0)
            {
                // Try lowering the MSAA sample size until we find a  config
                int sampleCount = __samples;
                while (sampleCount)
                {
                    GP_WARN("No EGL config found for depth_size=%d and samples=%d. Trying samples=%d instead.", depthSizes[i], sampleCount, sampleCount / 2);
                    sampleCount /= 2;
                    eglConfigAttrs[1] = sampleCount > 0 ? 1 : 0;
                    eglConfigAttrs[3] = sampleCount;
                    if (eglChooseConfig(__eglDisplay, eglConfigAttrs, &__eglConfig, 1, &eglConfigCount) == EGL_TRUE && eglConfigCount > 0)
                    {
                        validConfig = true;
                        break;
                    }
                }

                __multiSampling = sampleCount > 0;

                if (validConfig)
                    break;
            }
            else
            {
                GP_WARN("No EGL config found for depth_size=%d.", depthSizes[i]);
            }
        }

        if (!validConfig)
        {
            GP_ERROR("eglChooseConfig");
            return NULL;
        }

        __eglContext = eglCreateContext(__eglDisplay, __eglConfig, EGL_NO_CONTEXT, eglContextAttrs);
        if (__eglContext == EGL_NO_CONTEXT)
        {
            GP_ERROR("eglCreateContext");
            return NULL;
        }
    }

    __eglSurface = eglCreateWindowSurface(__eglDisplay, __eglConfig, NULL, eglSurfaceAttrs);
    if (__eglSurface == EGL_NO_SURFACE)
    {
        GP_ERROR("eglCreateWindowSurface");
        return NULL;
    }

    if (eglMakeCurrent(__eglDisplay, __eglSurface, __eglSurface, __eglContext) != EGL_TRUE)
    {
        GP_ERROR("eglMakeCurrent");
        return NULL;
    }

    // Initialize OpenGL ES extensions.
    __glExtensions = (const char*)glGetString(GL_EXTENSIONS);

    if (strstr(__glExtensions, "GL_OES_vertex_array_object") || strstr(__glExtensions, "GL_ARB_vertex_array_object"))
    {
        glBindVertexArray = (PFNGLBINDVERTEXARRAYOESPROC)eglGetProcAddress("glBindVertexArrayOES");
        glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSOESPROC)eglGetProcAddress("glDeleteVertexArraysOES");
        glGenVertexArrays = (PFNGLGENVERTEXARRAYSOESPROC)eglGetProcAddress("glGenVertexArraysOES");
        //glIsVertexArray = (PFNGLISVERTEXARRAYOESPROC)eglGetProcAddress("glIsVertexArrayOES");
    }

    // Set vsync.
    eglSwapInterval(__eglDisplay, WINDOW_VSYNC ? 1 : 0);

    return platform;
}

void cleanupX11()
{
}

double timespec2millis(struct timespec *a)
{
    GP_ASSERT(a);
    return (1000.0 * a->tv_sec) + (0.000001 * a->tv_nsec);
}

void updateWindowSize()
{
    int sizePacked = EM_ASM_INT_V({
        var canvas = document.getElementById('canvas');
        return canvas.clientWidth + (canvas.clientHeight << 16);
    });
    
    __windowSize[0] = sizePacked & 0xffff;
    __windowSize[1] = sizePacked >> 16;
    
    emscripten_set_canvas_size(__windowSize[0], __windowSize[1]);
}

EM_BOOL mouse_callback(int eventType, const EmscriptenMouseEvent *e, void *userData)
{
    //printf("%d screen: (%ld,%ld), client: (%ld,%ld),%s%s%s%s button: %hu, buttons: %hu, movement: (%ld,%ld), canvas: (%ld,%ld)\n",
    //         eventType, e->screenX, e->screenY, e->clientX, e->clientY,
    //         e->ctrlKey ? " CTRL" : "", e->shiftKey ? " SHIFT" : "", e->altKey ? " ALT" : "", e->metaKey ? " META" : "",
    //         e->button, e->buttons, e->movementX, e->movementY, e->canvasX, e->canvasY);
    int x = e->canvasX;
    int y = e->canvasY;
    gameplay::Mouse::MouseEvent mouseEvt;
    bool eventConsumed = false;
    
    if (eventType == EMSCRIPTEN_EVENT_MOUSEDOWN)
    {
        switch(e->button)
        {
        default:
            __leftMouseButtonPressed = true;
            mouseEvt = gameplay::Mouse::MOUSE_PRESS_LEFT_BUTTON;
            break;
        case 1:
            mouseEvt = gameplay::Mouse::MOUSE_PRESS_MIDDLE_BUTTON;
            break;
        case 2:
            mouseEvt = gameplay::Mouse::MOUSE_PRESS_RIGHT_BUTTON;
            break;
        }
        eventConsumed = gameplay::Platform::mouseEventInternal(mouseEvt, x, y, 0);
        if (!eventConsumed && e->button == 0)
        {
            gameplay::Platform::touchEventInternal(gameplay::Touch::TOUCH_PRESS, x, y, 0, true);
        }
    }
    if (eventType == EMSCRIPTEN_EVENT_MOUSEUP)
    {
        switch(e->button)
        {
        default:
            __leftMouseButtonPressed = false;
            mouseEvt = gameplay::Mouse::MOUSE_RELEASE_LEFT_BUTTON;
            break;
        case 1:
            mouseEvt = gameplay::Mouse::MOUSE_RELEASE_MIDDLE_BUTTON;
            break;
        case 2:
            mouseEvt = gameplay::Mouse::MOUSE_RELEASE_RIGHT_BUTTON;
            break;
        }
        eventConsumed = gameplay::Platform::mouseEventInternal(mouseEvt, x, y, 0);
        if (!eventConsumed && e->button == 0)
        {
            gameplay::Platform::touchEventInternal(gameplay::Touch::TOUCH_RELEASE, x, y, 0, true);
        }
    }
    if (eventType == EMSCRIPTEN_EVENT_MOUSEMOVE && (e->movementX != 0 || e->movementY != 0))
    {
        __mouseCapturePointX = x;
        __mouseCapturePointY = y;
        eventConsumed = gameplay::Platform::mouseEventInternal(gameplay::Mouse::MOUSE_MOVE, x, y, 0);
        if (!eventConsumed && e->button == 0)
        {
            if (__leftMouseButtonPressed)
            {
                gameplay::Platform::touchEventInternal(gameplay::Touch::TOUCH_MOVE, x, y, 0, true);
            }
        }
    }

    return 1;
}

EM_BOOL wheel_callback(int eventType, const EmscriptenWheelEvent *e, void *userData)
{
    //printf("%d wheel %.3f %.3f %.3f %ld\n",
    //       eventType, e->deltaX, e->deltaY, e->deltaZ, e->deltaMode);
    
    if (eventType == EMSCRIPTEN_EVENT_WHEEL)
    {
        gameplay::Platform::mouseEventInternal(gameplay::Mouse::MOUSE_WHEEL, __mouseCapturePointX, __mouseCapturePointY, -e->deltaY * 0.01);
    }
    
    return 1;
}
    
EM_BOOL keyboard_callback(int eventType, const EmscriptenKeyboardEvent *e, void *userData)
{
    /*
    printf("%d key: %s code: %s ctrl: %d shift: %d alt: %d meta: %d charCode: %lu keyCode: %lu which: %lu\n", eventType,
           e->key, e->code, e->ctrlKey, e->shiftKey, e->altKey, e->metaKey, e->charCode, e->keyCode, e->which);
     //*/
    
    if (e->repeat)
        return 1;

    static bool capsOn = false;
    
    if (eventType == EMSCRIPTEN_EVENT_KEYDOWN)
    {
        if (e->keyCode == 0x10/*VK_CAPITAL*/)
            capsOn = !capsOn;

        gameplay::Platform::keyEventInternal(gameplay::Keyboard::KEY_PRESS, getKey(e->keyCode, e->shiftKey ^ capsOn));
        if (strlen(e->key) == 1)
            gameplay::Platform::keyEventInternal(gameplay::Keyboard::KEY_CHAR, e->key[0]);
    }
    else if (eventType == EMSCRIPTEN_EVENT_KEYUP)
        gameplay::Platform::keyEventInternal(gameplay::Keyboard::KEY_RELEASE, getKey(e->keyCode, e->shiftKey ^ capsOn));
    return 1;
}
    
EM_BOOL resize_callback(int eventType, const EmscriptenUiEvent * uiEvent, void *userData)
{
    GP_ASSERT(eventType == EMSCRIPTEN_EVENT_RESIZE);
    
    int sizePacked = EM_ASM_INT_V({
        var canvas = document.getElementById('canvas');
        return canvas.clientWidth + (canvas.clientHeight << 16);
    });
    
    int width = sizePacked & 0xffff;
    int height = sizePacked >> 16;

    //GP_LOG("%dx%d %dx%d", width, height, __windowSize[0], __windowSize[1]);

    if (width != __windowSize[0] || height != __windowSize[1])
    {
        __windowSize[0] = width;
        __windowSize[1] = height;
        emscripten_set_canvas_size(width, height);  // resize the pixel width and height as well when canvas proportions on the page are changed
        gameplay::Platform::resizeEventInternal(static_cast<unsigned>(width), static_cast<unsigned>(height));
    }
    
    return 1;
}
    
void main_loop_iter(void* _game)
{
    Game* game = (Game*)_game;
    // if(__lastKeyCode)
    // {
    //     struct timeval t;
    //     gettimeofday(&t, NULL);
    //     double curTime = timeval2millis(&t);

    //     if(curTime - __lastKeyPressTime > 200)
    //     {
    //         Keyboard::Key gpkey = getKey(__lastKeyCode);
    //         gameplay::Platform::keyEventInternal(gameplay::Keyboard::KEY_RELEASE, gpkey);
    //         __lastKeyCode = 0;
    //     }
    // }

    double lastTimeSizePolled = 0.0;
    if (game)
    {
        // Game state will be uninitialized if game was closed through Game::exit()
        if (game->getState() == Game::UNINITIALIZED)
            return;

        // since there is no way to listen for resize events for a canvas element, but only for window
        // pool the canvas dimensions every frame and invoke resizeEvent if they are changed
        // resize_callback does the polling once per second
        if (game->getAbsoluteTime() > lastTimeSizePolled + 1.0)
        {
            lastTimeSizePolled = game->getAbsoluteTime();
            resize_callback(EMSCRIPTEN_EVENT_RESIZE, NULL, NULL);
        }

        game->frame();
    }

    eglSwapBuffers(__eglDisplay, __eglSurface);
}

int Platform::enterMessagePump()
{
    GP_ASSERT(_game);

    // initial viewport size is fully dependent on canvas size
    updateWindowSize();

    // Get the initial time.
    clock_gettime(CLOCK_REALTIME, &__timespec);
    __timeStart = timespec2millis(&__timespec);
    __timeAbsolute = 0L;

    // Run the game.
    _game->run();

    emscripten_set_mousedown_callback("#canvas", 0, true, mouse_callback);
    emscripten_set_mouseup_callback(0, 0, true, mouse_callback);
    emscripten_set_mousemove_callback(0, 0, true, mouse_callback);
    emscripten_set_wheel_callback("#canvas", 0, true, wheel_callback);
    emscripten_set_keydown_callback(0, 0, true, keyboard_callback);
    emscripten_set_keyup_callback(0, 0, true, keyboard_callback);
    emscripten_set_resize_callback(0, 0, false, &resize_callback);
    emscripten_set_main_loop_arg(&main_loop_iter, (void *)_game, 0, 1);

    return 0;
}

void Platform::signalShutdown()
{
}

bool Platform::canExit()
{
    return true;
}

unsigned int Platform::getDisplayWidth()
{
    return __windowSize[0];
}

unsigned int Platform::getDisplayHeight()
{
    return __windowSize[1];
}

double Platform::getAbsoluteTime()
{

    clock_gettime(CLOCK_REALTIME, &__timespec);
    double now = timespec2millis(&__timespec);
    __timeAbsolute = now - __timeStart;

    return __timeAbsolute * 0.001;
}

void Platform::setAbsoluteTime(double time)
{
    __timeAbsolute = time * 1000.0;
}

bool Platform::isVsync()
{
    return __vsync;
}

void Platform::setVsync(bool enable)
{
    __vsync = enable;
    eglSwapInterval(__eglDisplay, __vsync ? 1 : 0);
}

void Platform::swapBuffers()
{
    eglSwapBuffers(__eglDisplay, __eglSurface);
}

void Platform::sleep(float s)
{
    usleep(long(s * 1000000));
}

void Platform::setMultiSampling(bool enabled)
{
    if (enabled == __multiSampling)
    {
        return;
    }

    // TODO
    __multiSampling = enabled;
}

bool Platform::isMultiSampling()
{
    return __multiSampling;
}

void Platform::setMultiTouch(bool enabled)
{
    // not supported
}

bool Platform::isMultiTouch()
{
    return false;
}

bool Platform::hasAccelerometer()
{
    return false;
}

void Platform::getAccelerometerValues(float* pitch, float* roll)
{
    GP_ASSERT(pitch);
    GP_ASSERT(roll);

    *pitch = 0;
    *roll = 0;
}

void Platform::getSensorValues(float* accelX, float* accelY, float* accelZ, float* gyroX, float* gyroY, float* gyroZ)
{
    if (accelX)
    {
        *accelX = 0;
    }

    if (accelY)
    {
        *accelY = 0;
    }

    if (accelZ)
    {
        *accelZ = 0;
    }

    if (gyroX)
    {
        *gyroX = 0;
    }

    if (gyroY)
    {
        *gyroY = 0;
    }

    if (gyroZ)
    {
        *gyroZ = 0;
    }
}

void Platform::getArguments(int* argc, char*** argv)
{
    if (argc)
        *argc = __argc;
    if (argv)
        *argv = __argv;
}

bool Platform::hasMouse()
{
    return true;
}

void Platform::setMouseCaptured(bool captured)
{
}

bool Platform::isMouseCaptured()
{
    return __mouseCaptured;
}

void Platform::setCursorVisible(bool visible)
{
}

bool Platform::isCursorVisible()
{
    return __cursorVisible;
}

void Platform::displayKeyboard(bool display)
{
    // not supported
}

void Platform::shutdownInternal()
{
    Game::getInstance()->shutdown();
}

bool Platform::isGestureSupported(Gesture::GestureEvent evt)
{
    return false;
}

void Platform::registerGesture(Gesture::GestureEvent evt)
{
}

void Platform::unregisterGesture(Gesture::GestureEvent evt)
{
}

bool Platform::isGestureRegistered(Gesture::GestureEvent evt)
{
    return false;
}

void Platform::pollGamepadState(Gamepad* gamepad)
{
}

bool Platform::launchURL(const char* url)
{
    EM_ASM_({window.open(Module.Pointer_stringify($0),'_blank');}, url);
    return true;
}

std::string Platform::displayFileDialog(size_t mode, const char* title, const char* filterDescription, const char* filterExtensions, const char* initialDirectory)
{
    return "";
}

const char * Platform::getTemporaryFolderPath( )
{
    return "";
}

const char * Platform::getDocumentsFolderPath( )
{
    return "";
}

const char * Platform::getAppPrivateFolderPath( )
{
    return "";
}

const char * Platform::getUserAgentString( )
{
    return "";
}

bool Platform::isTouchPressed()
{
    return false;
}

bool Platform::getTouchPosition(int index, int * outX, int * outY)
{
    return false;
}

}

#endif
#endif
